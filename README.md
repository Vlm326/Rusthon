# Rusthon

Небольшой учебный интерпретатор, написанный на Rust, созданный для того, чтобы **на практике** разобраться:

- как устроен простейший интерпретатор;
- как выглядит полный путь от текста программы до её выполнения;
- как использовать язык Rust в контексте написания собственного языка программирования.

> Rusthon **не претендует** на production-готовый язык. Это учебный проект, в котором важнее понятность архитектуры, чем количество фич.

---

## Содержание

- [Возможности и цели проекта](#возможности-и-цели-проекта)
- [Установка и сборка](#установка-и-сборка)
- [Запуск](#запуск)
- [Пример кода на Rusthon](#пример-кода-на-rusthon)
- [Архитектура проекта](#архитектура-проекта)
- [Стиль кодирования](#стиль-кодирования)
- [Тестирование](#тестирование)
- [Непрерывная интеграция-ci](#непрерывная-интеграция-ci)
- [Дорожная карта](#дорожная-карта)
- [Как внести вклад](#как-внести-вклад)
- [Лицензия](#лицензия)

---

## Возможности и цели проекта

### Основные цели

- Показать **полный пайплайн интерпретатора**:
  1. Лексический анализ (tokenizer / lexer);
  2. Синтаксический анализ (parser);
  3. Построение абстрактного синтаксического дерева (AST);
  4. Интерпретация / выполнение AST;
  5. Обработка ошибок с человекочитаемыми сообщениями.

- Дать практический опыт работы с:
  - системой типов Rust (владение, заимствование, `Option`, `Result`);
  - модульной структурой (`mod`, разбиение на файлы);
  - тестированием (`cargo test`);
  - статическими анализаторами (`clippy`, `rustfmt`);
  - потенциальной интеграцией с CI (GitHub Actions).

### Ожидаемый минимальный функционал языка

Точный набор возможностей языка развивается, но целевой минимум для Rusthon:

- Переменные и присваивание;
- Целочисленные литералы и строки;
- Базовые арифметические операции (`+`, `-`, `*`, `/`, `%`);
- Операторы сравнения (`==`, `!=`, `<`, `<=`, `>`, `>=`);
- Логические конструкции (`if`, `else`, при необходимости — `while`, `for`);
- Пользовательские функции (`def`), `return`.

Фокус — на **читаемом, учебном коде**, а не на максимальной производительности.

---

## Установка и сборка

### Предварительные требования

- Установленный **Rust** и **Cargo** (стабильный канал).  
  Проверить можно так:

```bash
rustc --version
cargo --version

Если Rust не установлен, рекомендуется установить через rustup

.
Клонирование репозитория

git clone https://github.com/Vlm326/Rusthon.git
cd Rusthon

Сборка

cargo build

Для сборки в релизной конфигурации:

cargo build --release

Запуск

    Ниже приведён типичный способ запуска бинарника Rust-проекта.
    Конкретный формат аргументов может меняться по мере развития проекта — актуальное поведение см. в main.rs.

Запуск интерпретатора (через cargo run)

Из корня репозитория:

cargo run

Возможные варианты поведения (в зависимости от реализованного интерфейса):

    REPL-режим: запуск без аргументов открывает простой интерактивный интерпретатор;

    Запуск скрипта: cargo run -- path/to/script.rsht (или другое расширение языка) выполняет указанный файл.

Если бинарник называется rusthon, после сборки его можно запускать напрямую:

# Debug-сборка
./target/debug/rusthon path/to/script.rsht

# Либо релиз
./target/release/rusthon path/to/script.rsht

Пример кода на Rusthon

Ниже — демонстрационный фрагмент, иллюстрирующий предполагаемый стиль языка:

# Однострочный комментарий

var x: int = 10
var y: int = 20
var message = "hello, rusthon"

if x < y {
    print(message)
} else {
    print("x is not less than y")
}

# Пример цикла (конкретный синтаксис зависит от реализации)
var i: int = 0
while i < 5 {
    print(i)
    i = i + 1
}

# Объявление функции
def sum(a, b) {
    return a + b
}

var result = sum(2, 3)
print(result)

Цель: сделать язык достаточно простым, чтобы читать его «с листа», и при этом показать реализацию типичных конструкций.
Архитектура проекта

Структура репозитория (упрощённо):

Rusthon/
├── src/
│   ├── main.rs        # Точка входа: парсинг аргументов, запуск интерпретатора/REPL
│   ├── lexer.rs       # Лексический анализатор (разбиение исходного кода на токены)
│   ├── parser.rs      # Синтаксический анализатор, построение AST
│   ├── ast.rs         # Определение узлов абстрактного синтаксического дерева
│   ├── interpreter.rs # Интерпретатор/исполнитель дерева
│   ├── errors.rs      # Описания ошибок, удобный вывод сообщений
│   └── ...            # Дополнительные модули по мере развития
├── Cargo.toml         # Описание crate'а и зависимостей
├── Cargo.lock
└── README.md

    Имя и полный состав модулей могут отличаться от приведённых выше, но логика разделения кода примерно такая:

        lexer знает только про текст и токены;

        parser знает про токены и AST;

        interpreter знает про AST и окружение выполнения;

        main склеивает всё вместе и отвечает за CLI/REPL.

Рекомендуемый подход к модульности:

    Каждый крупный компонент интерпретатора — в отдельном модуле/файле;

    Ядро языка (AST + интерпретатор) по возможности не должно зависеть от конкретного способа ввода/вывода (удобнее тестировать).

Стиль кодирования

Проект ориентируется на стандартные практики Rust-сообщества:

    Форматирование кода

    Используется rustfmt:

cargo fmt

Рекомендуется запускать перед коммитом.

Статический анализ

Рекомендуется использовать clippy:

    cargo clippy

    Это помогает ловить подозрительные места и неидиоматичный Rust-код.

    Общие принципы

        Говорящие имена функций, типов и переменных;

        Явные типы в публичных интерфейсах;

        Минимизация unwrap / expect в «боевом» коде (по возможности — аккуратная обработка ошибок);

        Логическое разбиение кода на небольшие функции.

Дорожная карта

Идеи для развития Rusthon:

Расширить синтаксис языка (циклы, функции, коллекции и т.п.);

Добавить более дружелюбные сообщения об ошибках с указанием строки/позиции;

Написать полноценный набор модульных и интеграционных тестов;

Оформить отдельную техническую документацию (например, docs/ с описанием грамматики и архитектуры);

Добавить примеры программ в отдельную папку (examples/);

    Подготовить небольшое «руководство по разработке интерпретатора» на основе кода проекта.

Как внести вклад

Проект в первую очередь учебный, но любые улучшения приветствуются.

    Сделайте форк репозитория;

    Создайте ветку для вашей фичи / исправления:

git checkout -b feature/my-awesome-feature

Внесите изменения, не забудьте про:

    cargo fmt
    cargo clippy
    cargo test

    Запушьте ветку и откройте Pull Request.

В описании PR полезно коротко указать:

    что было изменено;

    какие сценарии протестированы;

    нет ли изменений в поведении языка, о которых важно знать.