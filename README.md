# Rusthonü¶Ä

![CI](https://github.com/Vlm326/Rusthon/actions/workflows/ci.yml/badge.svg)
![License](https://img.shields.io/github/license/Vlm326/Rusthon)
![Issues](https://img.shields.io/github/issues/Vlm326/Rusthon)
![PRs](https://img.shields.io/github/issues-pr/Vlm326/Rusthon)
![Stars](https://img.shields.io/github/stars/Vlm326/Rusthon)


–ù–µ–±–æ–ª—å—à–æ–π –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º—ã–π —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π –Ω–∞ Rust.  
–¶–µ–ª—å –ø—Ä–æ–µ–∫—Ç–∞ ‚Äî –ø–æ—â—É–ø–∞—Ç—å, –∫–∞–∫ —Ä–µ–∞–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞—é—Ç **–ª–µ–∫—Å–µ—Ä, –ø–∞—Ä—Å–µ—Ä, AST, –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä**, –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –ø—Ä–æ—Å—Ç–∞—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞.

Rusthon ‚Äî –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π, –Ω–æ —É–∂–µ –¥–æ–≤–æ–ª—å–Ω–æ ¬´–∂–∏–≤–æ–π¬ª —è–∑—ã–∫:

- —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è —Ç–∏–ø–∏–∑–∞—Ü–∏—è (`int`, `bool`, `str`, `list`);
- –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è;
- `if / elif / else`;
- —Ü–∏–∫–ª—ã `while` –∏ –¥–≤–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ `for`;
- –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ `func`;
- —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏: `print`, `len`, `range`;
- —Å–ø–∏—Å–∫–∏ –∏ `for ‚Ä¶ in` –ø–æ —Å–ø–∏—Å–∫–∞–º, —Å—Ç—Ä–æ–∫–∞–º –∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º;
- –ª–µ–∫—Å–∏—á–µ—Å–∫–∏–µ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ (—Å—Ç–µ–∫ –æ–∫—Ä—É–∂–µ–Ω–∏–π) –∏ –≤—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π.

---

## –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

- [–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —è–∑—ã–∫–∞](#–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏-—è–∑—ã–∫–∞)
  - [–¢–∏–ø—ã](#—Ç–∏–ø—ã)
  - [–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ](#–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ)
  - [–í—ã—Ä–∞–∂–µ–Ω–∏—è –∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã](#–≤—ã—Ä–∞–∂–µ–Ω–∏—è-–∏-–æ–ø–µ—Ä–∞—Ç–æ—Ä—ã)
  - [–£—Å–ª–æ–≤–∏—è](#—É—Å–ª–æ–≤–∏—è)
  - [–¶–∏–∫–ª—ã](#—Ü–∏–∫–ª—ã)
  - [–§—É–Ω–∫—Ü–∏–∏](#—Ñ—É–Ω–∫—Ü–∏–∏)
  - [–°–ø–∏—Å–∫–∏](#—Å–ø–∏—Å–∫–∏)
  - [–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞](#—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è-–±–∏–±–ª–∏–æ—Ç–µ–∫–∞)
- [–ü—Ä–∏–º–µ—Ä –ø—Ä–æ–≥—Ä–∞–º–º—ã](#–ø—Ä–∏–º–µ—Ä-–ø—Ä–æ–≥—Ä–∞–º–º—ã)
- [–°–±–æ—Ä–∫–∞ –∏ –∑–∞–ø—É—Å–∫](#—Å–±–æ—Ä–∫–∞-–∏-–∑–∞–ø—É—Å–∫)
  - [–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è](#—Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è)
  - [–°–±–æ—Ä–∫–∞](#—Å–±–æ—Ä–∫–∞)
  - [–ó–∞–ø—É—Å–∫](#–∑–∞–ø—É—Å–∫)
- [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-–ø—Ä–æ–µ–∫—Ç–∞)
  - [–õ–µ–∫—Å–µ—Ä (`lexer.rs`)](#–ª–µ–∫—Å–µ—Ä-lexerrs)
  - [AST (`ast.rs`)](#ast-astrs)
  - [–ü–∞—Ä—Å–µ—Ä (`parser.rs`)](#–ø–∞—Ä—Å–µ—Ä-parserrs)
  - [–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä (`interpreter.rs`)](#–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä-interpreterrs)
  - [–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ (`stdlib.rs`)](#—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è-–±–∏–±–ª–∏–æ—Ç–µ–∫–∞-stdlibrs)
  - [–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ (`main.rs`)](#—Ç–æ—á–∫–∞-–≤—Ö–æ–¥–∞-mainrs)
- [–Ø–∑—ã–∫ Rusthon —Ñ–æ—Ä–º–∞–ª—å–Ω–æ](#—è–∑—ã–∫-rusthon-—Ñ–æ—Ä–º–∞–ª—å–Ω–æ)
  - [–ü—Ä–∏–º–µ—Ä —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –≤ –¥—É—Ö–µ BNF](#–ø—Ä–∏–º–µ—Ä-—Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞-–≤-–¥—É—Ö–µ-bnf)
- [–ö–∞–∫ —Ä–∞—Å—à–∏—Ä—è—Ç—å —è–∑—ã–∫](#–∫–∞–∫-—Ä–∞—Å—à–∏—Ä—è—Ç—å-—è–∑—ã–∫)
  - [–î–æ–±–∞–≤–∏—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é](#–¥–æ–±–∞–≤–∏—Ç—å-–≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é-—Ñ—É–Ω–∫—Ü–∏—é)
  - [–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä](#–¥–æ–±–∞–≤–∏—Ç—å-–Ω–æ–≤—ã–π-–æ–ø–µ—Ä–∞—Ç–æ—Ä)
- [–ü–ª–∞–Ω—ã –∏ TODO](#–ø–ª–∞–Ω—ã-–∏-todo)
- [–õ–∏—Ü–µ–Ω–∑–∏—è](#–ª–∏—Ü–µ–Ω–∑–∏—è)

---

## –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —è–∑—ã–∫–∞

### –¢–∏–ø—ã

–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –±–∞–∑–æ–≤—ã–µ —Ç–∏–ø—ã:

- `int` ‚Äî —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (`i64`);
- `bool` ‚Äî –ª–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø: `true` / `false`;
- `str` ‚Äî —Å—Ç—Ä–æ–∫–∞;
- `list` ‚Äî —Å–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π —è–∑—ã–∫–∞ (`list` –ø–æ–∫–∞ –≥–æ–º–æ–≥–µ–Ω–Ω–æ—Å—Ç—å –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç—Ä–æ–≥–æ, –Ω–æ —Ö—Ä–∞–Ω–∏—Ç `Vec<Value>`).

–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ç–∏–ø –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–∞:

```rust
pub enum Value {
    Int(i64),
    Bool(bool),
    Str(String),
    List(Vec<Value>),
    Unit, // "–Ω–∏—á–µ–≥–æ", –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —É print/return –±–µ–∑ –∑–Ω–∞—á–µ–Ω–∏—è –∏ —Ç.–ø.
}
````

### –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

–û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö ‚Äî —á–µ—Ä–µ–∑ `var` —Å —è–≤–Ω—ã–º —Ç–∏–ø–æ–º:

```rht
var x: int = 10
var msg: str = "hello"
var ok: bool = true
var xs: list = [1, 2, 3]
```

–ü—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–µ ‚Äî –ø—Ä–æ—Å—Ç–æ `=`:

```rht
x = x + 1
msg = "new message"
```

–¢–∏–ø –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –ø—Ä–∏ **–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏** (`VarDecl`). –î–∞–ª—å—à–µ —Ç–∏–ø—ã –Ω–µ –º–µ–Ω—è—é—Ç—Å—è.

### –í—ã—Ä–∞–∂–µ–Ω–∏—è –∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã

–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è:

* –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞: `+`, `-`, `*`, `/`;
* —Å—Ä–∞–≤–Ω–µ–Ω–∏—è: `==`, `!=`, `<`, `<=`, `>`, `>=`.

–ü—Ä–∏–º–µ—Ä—ã:

```rht
var a: int = 2 + 3 * 4
var b: bool = a > 5
var s: str = "hello " + "world"
```

### –£—Å–ª–æ–≤–∏—è

–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π `if / elif / else` —Å –∫—Ä—É–≥–ª–æ–π —Å–∫–æ–±–∫–æ–π –≤–æ–∫—Ä—É–≥ —É—Å–ª–æ–≤–∏—è –∏ `{}` –¥–ª—è –±–ª–æ–∫–∞:

```rht
if (x < 0) {
    print("x < 0")
} elif (x == 0) {
    print("x == 0")
} else {
    print("x > 0")
}
```

–í AST —ç—Ç–æ:

```rust
Branch {
    cond: Expr,
    then_branch: Vec<Stmt>,
    else_if_branches: Vec<Stmt>, // –≤–Ω—É—Ç—Ä–∏ Stmt::ElseIfBranch
    else_branch: Vec<Stmt>,
}
```

### –¶–∏–∫–ª—ã

#### `while`

```rht
var i: int = 0
while (i < 3) {
    print(i)
    i = i + 1
}
```

–í –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–µ —É—Å–ª–æ–≤–∏–µ –¥–æ–ª–∂–Ω–æ –¥–∞–≤–∞—Ç—å `bool`, –∏–Ω–∞—á–µ ‚Äî panic.

#### `for` (–≤–∞—Ä–∏–∞–Ω—Ç foreach)

–ï—Å–ª–∏ –ø–æ—Å–ª–µ `for` —Å—Ä–∞–∑—É –∏–¥—ë—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∏ `in`, —ç—Ç–æ foreach-—Ñ–æ—Ä–º–∞:

```rht
// 1) for i in N:  i = 0..N-1
for i in 5 {
    print(i)
}

// 2) for ch in "hi!"
for ch in "hi!" {
    print(ch)
}

// 3) for v in —Å–ø–∏—Å–æ–∫
var xs: list = [10, 20, 30]
for v in xs {
    print(v)
}
```

–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è:

* `for i in 5` ‚Äî `i` –ø—Ä–æ–±–µ–≥–∞–µ—Ç –æ—Ç `0` –¥–æ `4`;
* `for ch in "hi!"` ‚Äî `ch` ‚Äî —Å—Ç—Ä–æ–∫–∞ –¥–ª–∏–Ω–æ–π 1 (—Å–∏–º–≤–æ–ª);
* `for v in xs` ‚Äî `v` ‚Äî —ç–ª–µ–º–µ–Ω—Ç—ã —Å–ø–∏—Å–∫–∞.

#### `for` (–≤–∞—Ä–∏–∞–Ω—Ç —Å —É—Å–ª–æ–≤–∏–µ–º)

–í—Ç–æ—Ä–æ–π –≤–∞—Ä–∏–∞–Ω—Ç ‚Äî –ø—Å–µ–≤–¥–æ-C-—Å—Ç–∏–ª—å, –Ω–æ –≤ —É–ø—Ä–æ—â—ë–Ω–Ω–æ–º –≤–∏–¥–µ: `for (expr) { ... }`.

–°–µ–π—á–∞—Å –æ–Ω —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –∫–∞–∫ ¬´—Ü–∏–∫–ª —Å —É—Å–ª–æ–≤–∏–µ–º¬ª, —Ç–æ –µ—Å—Ç—å —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ **–∞–Ω–∞–ª–æ–≥ while** —Å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–æ–º:

```rht
for (x < 10) {
    print(x)
    x = x + 1
}
```

–í AST:

```rust
For {
    cond: Expr,
    body: Vec<Stmt>,
}
```

(–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ —à–∞–≥ –ø–æ–∫–∞ –Ω–µ –≤—ã–Ω–µ—Å–µ–Ω—ã —è–≤–Ω–æ –≤ –≥—Ä–∞–º–º–∞—Ç–∏–∫—É, —ç—Ç–æ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∑–∂–µ.)

### –§—É–Ω–∫—Ü–∏–∏

–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏:

```rht
func add(a: int, b: int) {
    return a + b
}

func fact(n: int) {
    var res: int = 1
    var i: int = 1
    while (i <= n) {
        res = res * i
        i = i + 1
    }
    return res
}
```

–í–æ–∑–≤—Ä–∞—Ç –∑–Ω–∞—á–µ–Ω–∏—è ‚Äî —á–µ—Ä–µ–∑ `return`.
`return` –º–æ–∂–µ—Ç –±—ã—Ç—å –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ ‚Äî —Ç–æ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è `Unit`.

–§—É–Ω–∫—Ü–∏–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ AST –∫–∞–∫:

```rust
pub struct Function {
    pub name: String,
    pub params: Vec<(String, Type)>,
    pub body: Vec<Stmt>,
}
```

–ò –≤ `Program`:

```rust
pub struct Program {
    pub functions: Vec<Function>,
    pub stmts: Vec<Stmt>, // –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã
}
```

–í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏:

```rht
var s: int = add(2, 3)
print(s)
```

–ü—Ä–∏ –≤—ã–∑–æ–≤–µ:

* —Å–æ–∑–¥–∞—ë—Ç—Å—è –Ω–æ–≤—ã–π `scope` (–Ω–æ–≤—ã–π `HashMap` –≤ `env_stack`);
* –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–ª–∞–¥—É—Ç—Å—è –∫–∞–∫ –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ;
* –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–µ–ª–æ; –ø—Ä–∏ `return` –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞—Ä—É–∂—É;
* –ª–æ–∫–∞–ª—å–Ω–∞—è –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ —É–¥–∞–ª—è–µ—Ç—Å—è.

### –°–ø–∏—Å–∫–∏

–õ–∏—Ç–µ—Ä–∞–ª—ã —Å–ø–∏—Å–∫–æ–≤:

```rht
var xs: list = [1, 2, 3]
var strs: list = ["hello", "world"]
```

–í–Ω—É—Ç—Ä–∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–∞:

```rust
Expr::ListLiteral(Vec<Expr>) ‚Üí Value::List(Vec<Value>)
```

–°–ø–∏—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è, –≤ —á–∞—Å—Ç–Ω–æ—Å—Ç–∏, –¥–ª—è `for v in xs` –∏ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ `len(xs)`.

### –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞

–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –≤ `stdlib.rs` —á–µ—Ä–µ–∑ —Ñ—É–Ω–∫—Ü–∏—é:

```rust
pub fn call_builtin(name: &str, args: &Vec<Value>) -> Option<Value>
```

–°–µ–π—á–∞—Å –µ—Å—Ç—å:

#### `print(...)`

–í—ã–≤–æ–¥–∏—Ç –≤—Å–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –ø–µ—Ä–µ–≤–æ–¥ —Å—Ç—Ä–æ–∫–∏:

```rht
print("answer =", 42)
```

–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç `int`, `bool`, `str`, `list`, `Unit`.

#### `len(x)`

–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–ª–∏–Ω—É —Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ —Å–ø–∏—Å–∫–∞:

```rht
var s: str = "hello"
var xs: list = [1, 2, 3]

print(len(s))   # 5
print(len(xs))  # 3
```

#### `range(...)`

–°–æ–∑–¥–∞—ë—Ç —Å–ø–∏—Å–æ–∫ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª:

```rht
range(n)      # [0, 1, 2, ..., n-1]
range(a, b)   # [a, a+1, ..., b-1]

for i in range(5) {
    print(i)
}
```

---

## –ü—Ä–∏–º–µ—Ä –ø—Ä–æ–≥—Ä–∞–º–º—ã

–§—Ä–∞–≥–º–µ–Ω—Ç –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —è–∑—ã–∫–∞:

```rht
func add(a: int, b: int) {
    return a + b
}

func fact(n: int) {
    var res: int = 1
    var i: int = 1
    while (i <= n) {
        res = res * i
        i = i + 1
    }
    return res
}

func test_if(x: int) {
    if (x < 0) {
        print("x < 0")
    } elif (x == 0) {
        print("x == 0")
    } else {
        print("x > 0")
    }
}

func main_logic() {
    print("== —Ñ—É–Ω–∫—Ü–∏–∏ add –∏ fact ==")
    var s: int = add(2, 3)
    print("add(2, 3) =")
    print(s)

    var f: int = fact(5)
    print("fact(5) =")
    print(f)

    print("== if / elif / else ==")
    test_if(-1)
    test_if(0)
    test_if(1)

    print("== foreach –ø–æ range –∏ list ==")
    for i in range(5) {
        print(i)
    }

    var xs: list = [10, 20, 30]
    for v in xs {
        print(v)
    }
}

var answer: int = 42
print("== –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ main_logic ==")
print(answer)
main_logic()
```

---

## –°–±–æ—Ä–∫–∞ –∏ –∑–∞–ø—É—Å–∫

### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è

* –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π **Rust toolchain** (—Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è);
* `cargo` –≤ `$PATH`.

–ü—Ä–æ–≤–µ—Ä–∏—Ç—å:

```bash
rustc --version
cargo --version
```

### –°–±–æ—Ä–∫–∞

–ö–ª–æ–Ω–∏—Ä—É–µ–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∏ —Å–æ–±–∏—Ä–∞–µ–º:

```bash
git clone https://github.com/<USER>/<REPO>.git
cd <REPO>

# Debug-—Å–±–æ—Ä–∫–∞
cargo build

# Release-—Å–±–æ—Ä–∫–∞
cargo build --release
```

–ü–æ—Å–ª–µ `cargo build --release` –±–∏–Ω–∞—Ä–Ω–∏–∫ –ø–æ—è–≤–∏—Ç—Å—è –≤:

```text
target/release/Rusthon
```

### –ó–∞–ø—É—Å–∫

Rusthon –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ø—É—Ç—å –∫ `.rht`-—Ñ–∞–π–ª—É –ø–µ—Ä–≤—ã–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º:

```bash
./target/release/Rusthon path/to/program.rht
```

–ï—Å–ª–∏ —Ñ–∞–π–ª–∞ –Ω–µ—Ç –∏–ª–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –Ω–µ `.rht`, –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —Å –æ—à–∏–±–∫–æ–π.

–ü—Ä–∏–º–µ—Ä:

```bash
./target/release/Rusthon examples/demo.rht
```

---

## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª–µ–π –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫–∞—è:

```text
src/
  ast.rs          // –æ–ø–∏—Å–∞–Ω–∏–µ AST: Expr, Stmt, Function, Program, Type, BinOp
  lexer.rs        // –ª–µ–∫—Å–µ—Ä: —Ä–∞–∑–±–æ—Ä —Ç–µ–∫—Å—Ç–∞ –≤ —Ç–æ–∫–µ–Ω—ã
  parser.rs       // –ø–∞—Ä—Å–µ—Ä: —Ç–æ–∫–µ–Ω—ã -> AST
  interpreter.rs  // –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä: –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ AST
  stdlib.rs       // –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (print, len, range, ...)
  main.rs         // —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞: —Å–≤—è–∑—ã–≤–∞–µ—Ç –≤—Å—ë –≤–º–µ—Å—Ç–µ
```

### –õ–µ–∫—Å–µ—Ä (`lexer.rs`)

–û—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Ä–∞–∑–±–æ—Ä —Å—ã—Ä–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –≤ —Ç–æ–∫–µ–Ω—ã (`Token`):

* –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –ø—Ä–æ–±–µ–ª—ã –∏ —Ç–∞–±—ã;
* –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç:

  * `Ident(String)`, `IntLiteral(i64)`, `StrLiteral(String)`;
  * –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞: `var`, `func`, `if`, `elif`, `else`, `while`, `for`, `in`, `true`, `false`, `return` –∏ —Ç.–¥.
  * –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏: `+`, `-`, `*`, `/`, `%`, `==`, `!=`, `<`, `<=`, `>`, `>=`, `(`, `)`, `{`, `}`, `[`, `]`, `:`, `,`.

–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–∞—Ä—Å–µ—Ä–æ–º –∫–∞–∫ –∏—Ç–µ—Ä–∞—Ç–æ—Ä:

```rust
let lexer = Lexer::new(&program_text);
let mut parser = Parser::new(lexer);
```

### AST (`ast.rs`)

**AST (Abstract Syntax Tree)** ‚Äî —ç—Ç–æ –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω–æ–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–æ–µ –¥–µ—Ä–µ–≤–æ, —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä–∞—è –æ–ø–∏—Å—ã–≤–∞–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º—É –Ω–µ –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫–∏, –∞ –≤ –≤–∏–¥–µ –∏–µ—Ä–∞—Ä—Ö–∏–∏ —É–∑–ª–æ–≤: –≤—ã—Ä–∞–∂–µ–Ω–∏—è, –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã, —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —Ç.–ø.

–ü—Ä–∏–º–µ—Ä—ã:

* `Expr::Binary` ‚Äî –±–∏–Ω–∞—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ (`a + b`, `x < y`, ...);
* `Stmt::VarDecl` ‚Äî –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π;
* `Stmt::While` ‚Äî —Ü–∏–∫–ª `while`;
* `Stmt::ForEach` ‚Äî `for v in xs { ... }`;
* `Function` ‚Äî –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è —Ñ—É–Ω–∫—Ü–∏—è;
* `Program` ‚Äî –∫–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞ (—Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π + –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤).

–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä —Ö–æ–¥–∏—Ç –ø–æ —ç—Ç–æ–º—É –¥–µ—Ä–µ–≤—É –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º—É.

### –ü–∞—Ä—Å–µ—Ä (`parser.rs`)

–ü–∞—Ä—Å–µ—Ä –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –ø–æ—Ç–æ–∫ `Token` –≤ AST:

* —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π —Å–ø—É—Å–∫;

* —É—á–∏—Ç—ã–≤–∞–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤:

  * `parse_primary` ‚Üí —á–∏—Å–ª–∞, —Å—Ç—Ä–æ–∫–∏, –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã, `(...)`, —Å–ø–∏—Å–∫–∏ `[...]`;
  * `parse_factor` ‚Üí —É–º–Ω–æ–∂–µ–Ω–∏–µ/–¥–µ–ª–µ–Ω–∏–µ –∏ –≤—ã–∑–æ–≤—ã `func(...)`;
  * `parse_term` ‚Üí `*` –∏ `/`;
  * `parse_expr` ‚Üí `+`, `-`, —Å—Ä–∞–≤–Ω–µ–Ω–∏—è `==`, `!=`, `<`, `>`, ...

* –ø–∞—Ä—Å–∏—Ç:

  * –æ–±—ä—è–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö: `var name: type = expr`;
  * –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è: `name = expr`;
  * `if / elif / else`;
  * `while` –∏ `for`;
  * `func name(params) { body }`;
  * `return`.

–í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø–∞—Ä—Å–µ—Ä –≤—ã–∑—ã–≤–∞–µ—Ç `error(...)`, –≤—ã–≤–æ–¥–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ç–µ–∫—É—â–∏–º —Ç–æ–∫–µ–Ω–æ–º –∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å.

### –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä (`interpreter.rs`)

–ò—Å–ø–æ–ª–Ω—è–µ—Ç AST:

* —Ö—Ä–∞–Ω–∏—Ç **—Å—Ç–µ–∫ –æ–∫—Ä—É–∂–µ–Ω–∏–π**:

  ```rust
  struct Interpreter {
      env_stack: Vec<HashMap<String, Value>>,
      functions: HashMap<String, Function>,
  }
  ```

* –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ:

  * –∑–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ `Function` –≤ `functions`;
  * –≤—ã–ø–æ–ª–Ω—è–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã (`program.stmts`).

* –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏:

  * `push_env()` / `pop_env()`;
  * –Ω–æ–≤—ã–π scope —Å–æ–∑–¥–∞—ë—Ç—Å—è:

    * –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ —Ñ—É–Ω–∫—Ü–∏—é;
    * –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –±–ª–æ–∫–∞ (`exec_block`) for/while/if-–≤–µ—Ç–∫–∏.

* –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:

  * `define_var(name, value)` ‚Äî –∫–ª–∞–¥—ë—Ç –≤ —Ç–µ–∫—É—â–∏–π (–≤–µ—Ä—Ö–Ω–∏–π) scope;
  * `assign_var` ‚Äî –∏—â–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö –ø–æ —Å—Ç–µ–∫—É –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ;
  * `get_var` ‚Äî –∏—â–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏.

* –≤—ã—Ä–∞–∂–µ–Ω–∏—è:

  * `eval_expr(&Expr) -> Value`;
  * –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞ –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –≤ `eval_bin`.

* –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã:

  * `exec_stmt(&Stmt) -> Option<Value>`:

    * `None` ‚Äî –æ–±—ã—á–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ;
    * `Some(value)` ‚Äî –ø—Ä–æ–±—Ä–æ—à–µ–Ω–Ω—ã–π `return` –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏.

### –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ (`stdlib.rs`)

–°–æ–¥–µ—Ä–∂–∏—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –æ–∫—Ä—É–∂–µ–Ω–∏—è:

* `print(...)`
* `len(x)`
* `range(...)`

–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ—Ç –≤—ã–∑–≤–∞—Ç—å builtin:

```rust
if let Some(result) = stdlib::call_builtin(&callee, &value_args) {
    return result;
}
```

–ê –µ—Å–ª–∏ —Ç–∞–∫–æ–µ –∏–º—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –ø—ã—Ç–∞–µ—Ç—Å—è –≤—ã–∑–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫—É—é —Ñ—É–Ω–∫—Ü–∏—é.

### –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ (`main.rs`)

–°–≤—è–∑—ã–≤–∞–µ—Ç –≤—Å—ë –≤–º–µ—Å—Ç–µ:

```rust
use std::env;
use std::fs;

mod ast;
mod interpreter;
mod lexer;
mod parser;
mod stdlib;

use interpreter::Interpreter;
use lexer::Lexer;
use parser::Parser;

fn main() {
    // –ù–∞—Ö–æ–¥–∏–º –ø–µ—Ä–≤—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –Ω–∞ ".rht"
    let args: Vec<String> = env::args().collect();

    let path = args
        .iter()
        .find(|arg| arg.ends_with(".rht"))
        .expect("‚ùå You must pass a .rht program file as an argument.")
        .clone();

    // –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª –ø—Ä–æ–≥—Ä–∞–º–º—ã
    let program_text = fs::read_to_string(&path)
        .expect("‚ùå Failed to read the program file.");

    // –õ–µ–∫—Å–µ—Ä + –ø–∞—Ä—Å–µ—Ä ‚Üí AST
    let lexer = Lexer::new(&program_text);
    let mut parser = Parser::new(lexer);
    let program = parser.parse_program();

    // –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä
    let mut interp = Interpreter::new();
    interp.run(&program);
}
```

---

## –Ø–∑—ã–∫ Rusthon —Ñ–æ—Ä–º–∞–ª—å–Ω–æ

### –ü—Ä–∏–º–µ—Ä —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –≤ –¥—É—Ö–µ BNF

–≠—Ç–æ –Ω–µ —Å—Ç—Ä–æ–≥–∏–π EBNF, –Ω–æ –¥–∞—ë—Ç –æ–±—â–µ–µ –æ—â—É—â–µ–Ω–∏–µ –≥—Ä–∞–º–º–∞—Ç–∏–∫–∏:

```text
program       ::= (function | stmt)* EOF

function      ::= "func" IDENT "(" param_list? ")" block
param_list    ::= param ("," param)*
param         ::= IDENT ":" type

type          ::= "int" | "bool" | "str" | "list"

stmt          ::= var_decl
                | assign
                | if_stmt
                | while_stmt
                | for_stmt
                | return_stmt
                | expr_stmt

var_decl      ::= "var" IDENT ":" type "=" expr NEWLINE?

assign        ::= IDENT "=" expr NEWLINE?

if_stmt       ::= "if" "(" expr ")" block
                  ("elif" "(" expr ")" block)*
                  ("else" block)?

while_stmt    ::= "while" "(" expr ")" block

for_stmt      ::= "for" "(" expr ")" block
                | "for" IDENT "in" expr block

return_stmt   ::= "return" expr? NEWLINE?

expr_stmt     ::= expr NEWLINE?

block         ::= "{" NEWLINE* stmt* NEWLINE* "}"

expr          ::= term (("+" | "-" | "==" | "!=" | "<" | "<=" | ">" | ">=") term)*

term          ::= factor (("*" | "/") factor)*

factor        ::= primary
                | primary "(" arg_list? ")"  // –≤—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π

primary       ::= INT_LITERAL
                | STR_LITERAL
                | "true"
                | "false"
                | IDENT
                | "(" expr ")"
                | list_literal

list_literal  ::= "[" (expr ("," expr)*)? "]"

arg_list      ::= expr ("," expr)*
```

---

## –ö–∞–∫ —Ä–∞—Å—à–∏—Ä—è—Ç—å —è–∑—ã–∫

### –î–æ–±–∞–≤–∏—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é

1. –û—Ç–∫—Ä—ã—Ç—å `stdlib.rs`.
2. –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –∫–µ–π—Å –≤ `match name`:

```rust
"upper" => {
    if args.len() != 1 {
        panic!("upper() expects exactly 1 argument");
    }

    let s = match &args[0] {
        Value::Str(s) => s.clone(),
        _ => panic!("upper() expects a string"),
    };

    Some(Value::Str(s.to_uppercase()))
}
```

3. –¢–µ–ø–µ—Ä—å –≤ —è–∑—ã–∫–µ –º–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å:

```rht
print(upper("hello"))
```

### –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä

1. –î–æ–±–∞–≤–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç –≤ `BinOp` (–≤ `ast.rs`):

```rust
pub enum BinOp {
    // ...
    Mod, // %
}
```

2. –í `lexer.rs` —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ `%` –ª–µ–∫—Å–∏—Ç—Å—è –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω (`Percent` —É–∂–µ –µ—Å—Ç—å).
3. –í `parser.rs` –¥–æ–±–∞–≤–∏—Ç—å —Ä–∞–∑–±–æ—Ä `%` –≤ `parse_term`:

```rust
Token::Percent => {
    self.bump();
    let rhs = self.parse_factor();
    node = Expr::Binary {
        left: Box::new(node),
        op: BinOp::Mod,
        right: Box::new(rhs),
    };
}
```

4. –í `interpreter.rs` –¥–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É:

```rust
BinOp::Mod => match (left, right) {
    (Value::Int(l), Value::Int(r)) => Value::Int(l % r),
    _ => panic!("Type error in modulo"),
},
```

---

## –ü–ª–∞–Ω—ã –∏ TODO

–ò–¥–µ–∏ –¥–ª—è —Ä–∞–∑–≤–∏—Ç–∏—è Rusthon:

* [ ] –õ–æ–≥–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã `&&`, `||`, —É–Ω–∞—Ä–Ω—ã–π `!` —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏ –∏ short-circuit.
* [ ] –£–Ω–∞—Ä–Ω—ã–π –º–∏–Ω—É—Å (`-x`).
* [ ] –ë–æ–ª–µ–µ ¬´–Ω–∞—Å—Ç–æ—è—â–∏–π¬ª C-style `for (init; cond; step)` —Å —è–≤–Ω—ã–º–∏ –ø–æ–ª—è–º–∏ –≤ AST.
* [ ] –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ (`# ...` –∏–ª–∏ `// ...`) –Ω–∞ —É—Ä–æ–≤–Ω–µ –ª–µ–∫—Å–µ—Ä–∞.
* [ ] –ù–æ—Ä–º–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –æ—à–∏–±–æ–∫ (`Result` –≤–º–µ—Å—Ç–æ —Ç–æ—Ç–∞–ª—å–Ω—ã—Ö `panic!`).
* [ ] –¢–∏–ø–∏–∑–∞—Ü–∏—è —Å–ø–∏—Å–∫–æ–≤ (`list[int]`, `list[str]` –∏ —Ç.–ø.).
* [ ] –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π `main()` –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è `main` –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ ‚Äî –≤—ã–∑—ã–≤–∞—Ç—å –µ—ë –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏).
* [ ] –Æ–Ω–∏—Ç-—Ç–µ—Å—Ç—ã (`cargo test`) –¥–ª—è –ª–µ–∫—Å–µ—Ä–∞, –ø–∞—Ä—Å–µ—Ä–∞ –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–∞.
* [ ] CI (GitHub Actions) —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Å–±–æ—Ä–∫–æ–π –∏ –∑–∞–ø—É—Å–∫–æ–º —Ç–µ—Å—Ç–æ–≤.

---

## –õ–∏—Ü–µ–Ω–∑–∏—è

–õ–∏—Ü–µ–Ω–∑–∏—è —É–∫–∞–∑–∞–Ω–∞ –≤ —Ñ–∞–π–ª–µ [`LICENSE`](LICENSE).


